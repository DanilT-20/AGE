Варианты промежуточных точек:
1. Траектория не должна проходить через число A
  В проверку на неподходящую траекторию добавляем запись
  if x > y or x == A: return 0
2. Траектория должна проходить через число A
  В самом конце при вызове функции для дачи ответа добавляем запись
  print(f(1, A) * f(A, 20)), где 1 начальная точка, 20 - конечная

Варианты действий в проверке на неподходящую траекторию:
1. На увеличение числа
  if x > y: return 0
2. На уменьшение числа
  if x < y: return 0


==========================================================================

Пример 1:
Исполнитель преобразует число на экране. У исполнителя есть три команды, которые обозначены латинскими буквами:
А. Вычесть 1
В. Вычесть 3
С. Найти целую часть от деления на 2
Программа для исполнителя — это последовательность команд.
Сколько существует программ, для которых при исходном числе 19 результатом является число 3, при этом траектория вычислений не содержит числа 7 и содержит 10?

Решение 1:
  def f(x, y):
     if x == y: return 1
     if x < y or x == 7: return 0
     return f(x - 1, y) + f(x - 3, y) + f(x // 2, y)
  print(f(19, 10) * f(10, 3))

Пример 2:
Исполнитель преобразует число на экране. У исполнителя есть три команды, которым присвоены номера:
A. Прибавить 2
B. Прибавить 3
C. Умножить на 2
Программа для исполнителя – это последовательность команд.
Сколько существует программ, для которых при исходном числе 3 результатом является число 25, и при этом траектория вычислений содержит число 10 и не содержит 17?
Решение 2:
  def f(x, y):
     if x == y: return 1
     if x > y or x == 17: return 0
     return f(x + 2, y) + f(x + 3, y) + f(x * 2, y)
  print(f(3, 10) * f(10, 25))

Полезные алгоритмы:

1. Проверка числа на простоту
  def is_prime(num):
     if num < 2: return False
     for i in range(2, int(num  0.5) + 1):
         if num % i == 0:
             return False
     return True

2. Поиск всех делителей числа
  def delit(num):
     ans = []
     for i in range(2, int(num  0.5) + 1):
         if num % i == 0:
             ans.append(i)
             ans.append(num // i)
     ans = set(ans)

======================================================================

Проверка числа на соответствие маске:
  from fnmatch import fnmatch
  fnmatch('исходная строка', 'маска')
Результат работы функции - True или False

Обозначения в маске:
  ? - один любой символ
  * - любая последовательность
  [0-9] - одна любая цифра
  [a-z] - одна любая буква латинского алфавита
  [0-9a-z] - одна цифра или одна буква латинского алфавита
  [1, 3, a] - один любой символ из указанного набора

Примеры:
  fnmatch('1234', '[0-9][0-9][0-9][0-9]') -> True
  fnmatch('1234', '[0-9][0-9][0-9][0-3]') -> False
  fnmatch('1234', '[1, 2][2, 4][3, 6][4, 8]') -> True
  fnmatch('1234', '[1, 2][2, 4][3, 6][5, 8]') -> False
  fnmatch('1234', '?234') -> True
  fnmatch('1234', '?1234') -> False
  fnmatch('1234', '*234') -> True
  fnmatch('1234', '*1234') -> True
  fnmatch('1234', '*') -> True
  fnmatch('aboba', '[a][b][o][b][a]') -> True
  fnmatch('aboba', '[a][b][o][b][o]') -> False
  fnmatch('aboba', '[a][b][o][b][o, a]') -> True
  fnmatch('abob0', '[a][b][o][b][0-9a-z]') -> True
  fnmatch('abobz', '[a][b][o][b][0-9a-y]') -> False


========================================================================================

Определение границ поиска чисел:
Алгоритм:
Левую границу перебора устанавливаем по формуле:
  N - N % D, где N - минимальное число, подходящее под маску (составляем вручную)
  D - число, на которое должны делиться числа из условия (также выставляем как шаг цикла)

Правую границу берем как максимальное число из условия

Составление минимального числа, подходящего маске:
  ? заменяем на 0
  * удаляем

Пример:
Среди натуральных чисел, не превышающих 10**10, найдите все числа, соответствующие маске 1*2322?2,
делящиеся на 2024 без остатка.
Решение:
  for i in range(1232202 - 1232202 % 2024, 10 ** 10, 2024):